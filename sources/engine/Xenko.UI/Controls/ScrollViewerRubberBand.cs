// Copyright (c) Xenko contributors (https://xenko.com) and Silicon Studio Corp. (https://www.siliconstudio.co.jp)
// Distributed under the MIT license. See the LICENSE.md file in the project root for more information.
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;

using Xenko.Core;
using Xenko.Core.Annotations;
using Xenko.Core.Mathematics;
using Xenko.Engine;
using Xenko.Games;

namespace Xenko.UI.Controls
{
    /// <summary>
    /// Represents a scroll viewer with rubberband. 
    /// A scroll viewer element has an infinite virtual size defined by its <see cref="ScrollingMode"/>.
    /// The user can move in that virtual size by touching and panning on the screen.
    /// </summary>
    [DataContract(nameof(ScrollViewerRubberBand))]
    [CategoryOrder(40, ScrollBarCategory, Expand = ExpandRule.Auto)]
    [DebuggerDisplay("ScrollViewerRubberBand - Name={Name}")]
    public class ScrollViewerRubberBand : ContentControl
    {
        private const string ScrollBarCategory = "ScrollBar";
        private const int RefreshImageMargin = 10;

        private static readonly Dictionary<ScrollingMode2D, int[]> ScrollModeToDirectionIndicesMap = new Dictionary<ScrollingMode2D, int[]>
        {
            { ScrollingMode2D.None, new int[0] },
            { ScrollingMode2D.Horizontal, new[] { 0 } },
            { ScrollingMode2D.Vertical, new[] { 1 } },
            { ScrollingMode2D.HorizontalVertical, new[] { 0, 1 } },
        };

        /// <summary>
        /// The current offsets (in virtual pixels) generated by the scrolling on the <see cref="ContentControl.Content"/> element.
        /// </summary>
        private Vector3 _scrollOffsets;
        private Vector3 _actualScrollOffsets;

        /// <summary>
        /// The current speed of the scrolling in virtual pixels.
        /// </summary>
        private Vector3 _currentScrollingSpeed;

        /// <summary>
        /// True if any direction of the content can be scrolled.
        /// </summary>
        private bool _canScrollContent;

        private ScrollingMode2D _scrollMode = ScrollingMode2D.Vertical;
        private int[] _scrollModeToDirectionIndices = ScrollModeToDirectionIndicesMap[ScrollingMode2D.Vertical];
        private Color _scrollBarColor = Color.Gray;
        private ISpriteProvider _scrollBarThumbImage;
        private bool _touchScrollingEnabled = true;
        private bool _isUserScrollingViewer;
        private bool _userManuallyScrolled;
        private float _deceleration = 1500.0f;
        private Vector3 _accumulatedTouchTranslation;
        private Vector3 _contentRenderSizeWithPadding;
        private Vector3 _accumulatedDelayedTranslation;

        private bool _rubberBandEntered;
        private bool _rubberBandEasingOut;
        private bool _rubberBandUpSpace;
        private float _rubberBandStartOffset;

        private AnimatedImageElement _refreshElement;
        private float _refreshRubberBandOffsetRequired;
        private bool _refreshInitiated;

        private readonly ScrollBar[] _scrollBars =
        {
            new ScrollBar { Name = "Left/Right SB", Margin = new Thickness(0, 0, 0, 2), Visibility = Visibility.Collapsed, RotateThumbImage = true },
            new ScrollBar { Name = "Top/Bottom SB", Margin = new Thickness(0, 0, 2, 0), Visibility = Visibility.Collapsed },
        };

        private struct ScrollRequest
        {
            public Vector3 ScrollValue;
            public bool IsRelative;
        }

        /// <summary>
        /// The list of scrolling requests that need to be performed during the next <see cref="ArrangeOverride"/>
        /// </summary>
        private readonly List<ScrollRequest> _scrollingRequests = new List<ScrollRequest>();

        /// <summary>
        /// Indicate if the user is currently touching the scroll viewer and performing a scroll gesture with its finger.
        /// </summary>
        public bool IsUserScrollingViewer
        {
            get { return _isUserScrollingViewer; }
            private set
            {
                if (_isUserScrollingViewer == value)
                    return;

                _isUserScrollingViewer = value;
                OnIsUserScrollingViewerChanged();
            }
        }

        /// <summary>
        /// The viewport of the <see cref="ScrollViewer"/> in virtual pixels.
        /// </summary>
        public Vector3 ViewPort { get; private set; }

        /// <summary>
        /// Gets or sets the color of the scrolling bar.
        /// </summary>
        /// <userdoc>The color of the scrolling bar.</userdoc>
        [DataMember]
        [Display(category: ScrollBarCategory)]
        public Color ScrollBarColor
        {
            get { return _scrollBarColor; }
            set
            {
                if (_scrollBarColor == value)
                    return;

                _scrollBarColor = value;
                foreach (var scrollBar in _scrollBars)
                    scrollBar.BarColorInternal = value;
            }
        }

        /// <summary>
        /// Gets or sets the scrolling bar thickness in virtual pixels.
        /// </summary>
        /// <userdoc>The scrolling bar thickness in virtual pixels.</userdoc>
        [DataMember]
        [Display(category: ScrollBarCategory)]
        [DefaultValue(6.0f)]
        public float ScrollBarThickness { get; set; } = 6.0f;

        /// <summary>
        /// Indicate if the scrollbar fades out after scrolling stops.
        /// </summary>
        /// <userdoc>True if scrollbar fades out after scrolling stops.</userdoc>
        [DataMember]
        [Display(category: ScrollBarCategory)]
        [DefaultValue(true)]
        public bool ScrollBarHidesNoActivity { get; set; } = true;

        /// <summary>
        /// Gets or sets the image to display as slider thumb.
        /// </summary>
        /// <userdoc>The image to display as slider thumb.</userdoc>
        [DataMember]
        [Display(category: ScrollBarCategory)]
        [DefaultValue(null)]
        public ISpriteProvider ScrollBarThumbImage
        {
            get { return _scrollBarThumbImage; }
            set
            {
                _scrollBarThumbImage = value;
                foreach (var scrollBar in _scrollBars)
                    scrollBar.ThumbImage = value;
            }
        }

        /// <summary>
        /// The viewer allowed scrolling mode.
        /// </summary>
        /// <userdoc>The viewer allowed scrolling mode.</userdoc>
        [DataMember]
        [Display(category: BehaviorCategory)]
        [DefaultValue(ScrollingMode2D.Vertical)]
        public ScrollingMode2D ScrollMode
        {
            get { return _scrollMode; }
            set
            {
                if (_scrollMode == value)
                    return;

                _scrollMode = value;
                OnScrollModeChanged();
            }
        }

        /// <summary>
        /// Gets or sets the threshold distance over which a touch move starts scrolling.
        /// </summary>
        /// <userdoc>The threshold distance over which a touch move starts scrolling.</userdoc>
        [DataMember]
        [Display(category: BehaviorCategory)]
        [DefaultValue(10.0f)]
        public float ScrollStartThreshold { get; set; } = 10.0f;

        /// <summary>
        /// The automatic deceleration of the scroll after the user remove its finger from the screen. The unit is in virtual pixels.
        /// </summary>
        /// <userdoc>The automatic deceleration of the scroll after the user remove its finger from the screen. The unit is in virtual pixels.</userdoc>
        [DataMember]
        [Display(category: BehaviorCategory)]
        [DefaultValue(1500.0f)]
        public float Deceleration
        {
            get { return _deceleration; }
            set
            {
                if (float.IsNaN(value))
                    return;
                _deceleration = value;
            }
        }

        /// <summary>
        /// Gets or sets the value indicating if rubber banding should be enabled.
        /// </summary>
        [DataMember]
        [Display(category: BehaviorCategory)]
        [DefaultValue(true)]
        public bool RubberBandEnabled { get; set; } = true;

        /// <summary>
        /// Gets or sets the scrolling behavior on touches. True to allow the user to scroll by touching, false to forbid it.
        /// </summary>
        /// <userdoc>True to allow the user to scroll by touching, false to forbid it.</userdoc>
        [DataMember]
        [Display(category: BehaviorCategory)]
        [DefaultValue(true)]
        public bool TouchScrollingEnabled
        {
            get { return _touchScrollingEnabled; }
            set
            {
                if (_touchScrollingEnabled == value)
                    return;

                _touchScrollingEnabled = value;
                OnTouchScrollingEnabledChanged();
            }
        }

        /// <summary>
        /// Gets or sets the refresh animation sprite sheet to display in top or left rubberband empty area.
        /// </summary>
        /// <userdoc>The image to display as refresh animation.</userdoc>
        [DataMember]
        [Display(category: BehaviorCategory)]
        [DefaultValue(null)]
        public ISpriteProvider RefreshImage { get; set; }

        /// <summary>
        /// Gets a value that indicates whether the is currently touched down.
        /// </summary>
        [DataMemberIgnore]
        protected virtual bool IsTouchedDown { get; set; }

        public event EventHandler IsUserScrollingViewerChanged;

        public event CancelEventHandler Refreshed;

        public ScrollViewerRubberBand()
        {
            // put the scroll bars above the presenter and add them to the grid canvas
            foreach (var scrollBar in _scrollBars)
            {
                scrollBar.BarColorInternal = ScrollBarColor;
                scrollBar.Measure(Vector3.Zero); // set is measure valid to true
                SetVisualParent(scrollBar, this);
            }

            CanBeHitByUser = TouchScrollingEnabled;
            ClipToBounds = true;
        }

        /// <summary>
        /// Stops the scrolling at the current position.
        /// </summary>
        public void StopCurrentScrolling()
        {
            _currentScrollingSpeed = Vector3.Zero;
        }

        /// <summary>
        /// Indicate if the scroll viewer can scroll in the given direction.
        /// </summary>
        /// <param name="direction">The direction to use for the test</param>
        /// <returns><value>true</value> if the scroll viewer can scroll in the provided direction, or else <value>false</value></returns>
        public bool CanScroll(Orientation2D direction)
        {
            return ((int)_scrollMode) - 1 == (int)direction || _scrollMode == ScrollingMode2D.HorizontalVertical;
        }

        public override UIElement Content
        {
            get { return base.Content; }
            set
            {
                if (base.Content == value)
                    return;

                base.Content = value;

                // reset the current scrolling cache data
                StopScrolling();
                _actualScrollOffsets = _scrollOffsets = Vector3.Zero;

                VisualChildrenCollection.Sort(ScrollBarSorter.Instance);
            }
        }

        public override bool IsEnabled
        {
            set
            {
                if (!value)
                {
                    HideScrollBars();
                }

                base.IsEnabled = value;
            }
        }

        public void EndRefresh()
        {
            if (_refreshElement != null)
            {
                _refreshElement.Visibility = Visibility.Collapsed;
            }
        }

        protected internal void HideScrollBars()
        {
            if (ScrollBarHidesNoActivity)
            {
                foreach (var index in _scrollModeToDirectionIndices)
                {
                    _scrollBars[index].Visibility = Visibility.Collapsed;
                }
            }
        }

        /// <summary>
        /// Method triggered when <see cref="ScrollMode"/> changed.
        /// Can be overridden in inherited class to change the default behavior.
        /// </summary>
        protected virtual void OnScrollModeChanged()
        {
            _scrollModeToDirectionIndices = ScrollModeToDirectionIndicesMap[_scrollMode];
            _actualScrollOffsets = _scrollOffsets = Vector3.Zero;
            InvalidateMeasure();
        }

        /// <summary>
        /// Method triggered when <see cref="TouchScrollingEnabled"/> changed.
        /// Can be overridden in inherited class to change the default behavior.
        /// </summary>
        protected virtual void OnTouchScrollingEnabledChanged()
        {
            CanBeHitByUser = TouchScrollingEnabled;
        }

        protected virtual void OnIsUserScrollingViewerChanged()
        {
            IsUserScrollingViewerChanged?.Invoke(this, EventArgs.Empty);
        }

        private void OnRefreshElementSpriteChanged(object sender, EventArgs e)
        {
            // TODO: It would be better not to have to mark the entire ScrollViewer as Dirty.
            // Need a propagate IsDirty system to a parent that has IsTopLevelDirty property set to true
            IsDirty = true;
        }

        protected override void Update(GameTime time)
        {
            base.Update(time);

            if (!IsEnabled)
                return;

            var frameElapsedSeconds = (float)time.Elapsed.TotalSeconds;
            if (frameElapsedSeconds < MathUtil.ZeroTolerance)
                return;

            UpdateScrolling(frameElapsedSeconds);

            if (ScrollBarHidesNoActivity)
            {
                // Smoothly hide the scroll bars if the no movements
                foreach (var index in _scrollModeToDirectionIndices)
                {
                    var scrollBar = _scrollBars[index];
                    var speed = index == 0 ? _currentScrollingSpeed.X : _currentScrollingSpeed.Y;
                    var shouldFadeOutScrollingBar = MathUtil.IsZero(speed) && (!TouchScrollingEnabled || !IsUserScrollingViewer);
                    if (shouldFadeOutScrollingBar)
                    {
                        if (scrollBar.BarColorInternal.A != 0)
                        {
                            scrollBar.BarColorInternal.A = (byte)Math.Max(0, scrollBar.BarColorInternal.A - ScrollBarColor.A * frameElapsedSeconds);
                            if (scrollBar.BarColorInternal.A == 0)
                            {
                                scrollBar.Visibility = Visibility.Collapsed;
                            }
                            // redraw needed
                            IsDirty = true;
                        }
                    }
                    else
                    {
                        if (!scrollBar.IsVisible)
                        {
                            scrollBar.Visibility = Visibility.Visible;
                            scrollBar.BarColorInternal = ScrollBarColor;
                            // redraw needed
                            IsDirty = true;
                        }
                    }
                }
            }
        }

        private void UpdateScrolling(float frameElapsedSeconds)
        {
            Vector3 scrollTranslation;

            if (IsUserScrollingViewer || _userManuallyScrolled)
            {
                if (_userManuallyScrolled)
                {
                    if (_accumulatedDelayedTranslation != Vector3.Zero)
                    {
                        ScrollOfInternal(ref _accumulatedDelayedTranslation, false);
                        _accumulatedDelayedTranslation = Vector3.Zero;
                    }

                    _userManuallyScrolled = false;
                    return;
                }

                // nothing to do if no translation
                var noTranslation = true;
                foreach (var index in _scrollModeToDirectionIndices)
                {
                    // the touch system probably doesn't have a resolution that can give deltas in very small values
                    // in most cases this is a test for 'not zero', but I wanted something a little bigger than Epsilon, in case,
                    // eg. user holds controller ray on one spot but it "very slightly moves", which gives tiny translation 'noise'
                    var v = index == 0 ? _accumulatedTouchTranslation.X : _accumulatedTouchTranslation.Y;
                    if (Math.Abs(v) >= 0.2f)
                    {
                        noTranslation = false;
                        break;
                    }
                }
                if (noTranslation)
                    return;

                scrollTranslation = _accumulatedTouchTranslation;
                _accumulatedTouchTranslation = Vector3.Zero;

                // compute the scrolling speed based on current translation
                _currentScrollingSpeed = scrollTranslation / frameElapsedSeconds;
            }
            else // scrolling is free: compute the scrolling translation based on the scrolling speed and anchors
            {
                if (_rubberBandEntered)
                {
                    // ease out back to zero, like the anchor snapping effect below
                    if (!_rubberBandEasingOut)
                    {
                        _rubberBandEasingOut = true;
                        _scrollOffsets = _actualScrollOffsets;
                        StopCurrentScrolling();
                    }

                    scrollTranslation = Vector3.Zero;
                    foreach (var index in _scrollModeToDirectionIndices)
                    {
                        var offset = Math.Abs((index == 0 ? _scrollOffsets.X : _scrollOffsets.Y) - _rubberBandStartOffset);
                        var d = 10f * offset * frameElapsedSeconds;
                        if (offset - d < 1f)
                        {
                            d = offset;
                        }
                        if (!_rubberBandUpSpace)
                            d = -d;
                        if (index == 0)
                            scrollTranslation.X = d;
                        else
                            scrollTranslation.Y = d;
                    }

                    ScrollOfInternal(ref scrollTranslation, false);
                    return;
                }

                // nothing to do if no scrolling speed
                var noSpeed = true;
                foreach (var index in _scrollModeToDirectionIndices)
                {
                    var speed = index == 0 ? _currentScrollingSpeed.X : _currentScrollingSpeed.Y;
                    if (!MathUtil.IsZero(speed))
                    {
                        noSpeed = false;
                        break;
                    }
                }
                if (noSpeed)
                    return;

                scrollTranslation = _currentScrollingSpeed * frameElapsedSeconds;
            }

            // decrease the scrolling speed used for next frame
            var decrease = Deceleration * frameElapsedSeconds;
            foreach (var index in _scrollModeToDirectionIndices)
            {
                var speed = index == 0 ? _currentScrollingSpeed.X : _currentScrollingSpeed.Y;
                if (speed != 0f)
                {
                    var newSpeed = Math.Abs(speed) - decrease;
                    if (newSpeed > 0f)
                        newSpeed = Math.Sign(speed) * newSpeed;
                    else
                        newSpeed = 0f;
                    if (index == 0)
                        _currentScrollingSpeed.X = newSpeed;
                    else
                        _currentScrollingSpeed.Y = newSpeed;
                }
            }

            // update the scrolling position
            if (scrollTranslation != Vector3.Zero)
                ScrollOfInternal(ref scrollTranslation, false);
        }

        /// <summary>
        /// Go to the beginning of the scroll viewer's content in the provided direction.
        /// </summary>
        /// <param name="direction">The direction in which to scroll</param>
        /// <param name="stopScrolling">Indicate if the scrolling should be stopped after the scroll action.</param>
        public void ScrollToBeginning(Orientation2D direction, bool stopScrolling = true)
        {
            ScrollToExtremity(direction, stopScrolling, true);
        }

        /// <summary>
        /// Go to the end of the scroll viewer's content in the provided direction.
        /// </summary>
        /// <param name="direction">The direction in which to scroll</param>
        /// <param name="stopScrolling">Indicate if the scrolling should be stopped after the scroll action.</param>
        public void ScrollToEnd(Orientation2D direction, bool stopScrolling = true)
        {
            ScrollToExtremity(direction, stopScrolling, false);
        }

        private void ScrollToExtremity(Orientation2D direction, bool stopScrolling, bool isBeginning)
        {
            if (stopScrolling)
            {
                StopScrolling();
            }

            if (VisualContent == null || !CanScroll(direction))
                return;

            var position = Vector3.Zero;
            if (!isBeginning)
            {
                if (direction == Orientation2D.Horizontal)
                    position.X = ViewPort.X - _contentRenderSizeWithPadding.X;
                else
                    position.Y = ViewPort.Y - _contentRenderSizeWithPadding.Y;
            }
            ScrollTo(position, false);
        }

        /// <summary>
        /// Try to scroll to the provided position (in virtual pixels). 
        /// If the provided translation is too important, it is clamped.
        /// </summary>
        /// <remarks>Note that the computational cost of <see cref="ScrollTo"/> can be greatly higher than <see cref="ScrollOf"/> 
        /// when scrolling is delegated to a <see cref="Content"/> virtualizing its items. When possible, prefer call to <see cref="ScrollOf"/></remarks>
        /// <param name="scrollAbsolutePosition">The scroll offsets to apply</param>
        /// <param name="stopScrolling">Indicate if the scrolling should be stopped after the scroll action.</param>
        public void ScrollTo(Vector3 scrollAbsolutePosition, bool stopScrolling = true)
        {
            if (stopScrolling)
            {
                StopScrolling();
            }

            if (VisualContent == null)
                return;

            SetUserManuallyScrolled();

            if (IsArrangeValid) // the children size informations are still valid -> perform scrolling right away
            {
                UpdateScrollOffsetsAndContent(-scrollAbsolutePosition);
            }
            else // children may have changed of size -> delay scrolling to next draw call
            {
                InvalidateArrange(); // force next arrange to perform scrolls
                _scrollingRequests.Clear(); // optimization remove previous request when provided position is absolute
                _scrollingRequests.Add(new ScrollRequest { ScrollValue = scrollAbsolutePosition });
            }
        }

        /// <summary>
        /// Try to scroll of the provided scrolling translation value from the current position. 
        /// If the provided translation is too important, it is clamped.
        /// </summary>
        /// <param name="scrollTranslation">The scroll translation to perform (in virtual pixels)</param>
        /// <param name="stopScrolling">Indicate if the scrolling should be stopped after the scroll action.</param>
        /// <param name="delayToUpdate">Indicate if the scroll action should occur in the Update call.</param>
        public void ScrollOf(Vector3 scrollTranslation, bool stopScrolling = true, bool delayToUpdate = false)
        {
            SetUserManuallyScrolled();

            if (delayToUpdate)
            {
                if (stopScrolling)
                {
                    StopScrolling();
                }

                // ScrollOfInternal can set ArrangeChanged to true, which puts it out sync with rendering (causes a wobble in scrollbar)
                // delaying the actual call to within the Update call fixes that all up
                _accumulatedDelayedTranslation += scrollTranslation;
            }
            else
            {
                ScrollOfInternal(ref scrollTranslation, stopScrolling);
            }
        }

        private void ScrollOfInternal(ref Vector3 scrollTranslation, bool stopScrolling)
        {
            if (stopScrolling)
            {
                StopScrolling();
            }

            if (VisualContent == null)
                return;

            if (IsArrangeValid) // the children size informations are still valid -> perform scrolling right away
            {
                UpdateScrollOffsetsAndContent(_scrollOffsets - scrollTranslation);
            }
            else // children may have changed of size -> delay scrolling to next draw call
            {
                InvalidateArrange(); // force next arrange to perform scrolls
                _scrollingRequests.Add(new ScrollRequest { IsRelative = true, ScrollValue = scrollTranslation });
            }
        }

        protected override Vector3 MeasureOverride(Vector3 availableSizeWithoutMargins)
        {
            // measure size desired by the children
            var childDesiredSizeWithMargins = Vector3.Zero;
            if (VisualContent != null)
            {
                // remove space for padding in availableSizeWithoutMargins
                var childAvailableSizeWithMargins = CalculateSizeWithoutThickness(ref availableSizeWithoutMargins, ref padding);

                // if the content is not scrollable perform space virtualization from the scroll viewer side.
                foreach (var index in _scrollModeToDirectionIndices)
                {
                    if (index == 0)
                        childAvailableSizeWithMargins.X = float.PositiveInfinity;
                    else
                        childAvailableSizeWithMargins.Y = float.PositiveInfinity;
                }

                VisualContent.Measure(childAvailableSizeWithMargins);
                childDesiredSizeWithMargins = VisualContent.DesiredSizeWithMargins;
            }

            // add the padding to the child desired size
            var desiredSizeWithPadding = CalculateSizeWithThickness(ref childDesiredSizeWithMargins, ref padding);
            return desiredSizeWithPadding;
        }

        protected override Vector3 ArrangeOverride(Vector3 finalSizeWithoutMargins)
        {
            // calculate the remaining space for the child after having removed the padding space.
            ViewPort = finalSizeWithoutMargins;

            // arrange the content
            if (VisualContent != null)
            {
                // calculate the final size given to the child (scroll view virtual size)
                var childSizeWithoutPadding = CalculateSizeWithoutThickness(ref finalSizeWithoutMargins, ref padding);
                foreach (var index in _scrollModeToDirectionIndices)
                {
                    if (index == 0)
                        childSizeWithoutPadding.X = Math.Max(VisualContent.DesiredSizeWithMargins.X, childSizeWithoutPadding.X);
                    else
                        childSizeWithoutPadding.Y = Math.Max(VisualContent.DesiredSizeWithMargins.Y, childSizeWithoutPadding.Y);
                }

                // arrange the child
                VisualContent.Arrange(childSizeWithoutPadding, IsCollapsed);

                // the space desired by the child + the padding of the viewer
                var contentRenderSize = VisualContent.RenderSize;
                var contentRenderSizeWithMargins = CalculateSizeWithoutThickness(ref contentRenderSize, ref MarginInternal);
                _contentRenderSizeWithPadding = CalculateSizeWithoutThickness(ref contentRenderSizeWithMargins, ref padding);

                // if I'm currently easing out the rubberband space, I don't want to affect the scroll offsets in case an Arrange pass occurs
                // this is a problem because the scrolling is running freely, not user controlled, and inside UpdateScrollOffsets, it will force the offset to 0
                if (!_rubberBandEasingOut)
                {
                    // update the scrolling bars
                    UpdateScrollingBarsSize();

                    // update the scrolling
                    if (_scrollingRequests.Count > 0)
                    {
                        // perform the scrolling requests
                        foreach (var request in _scrollingRequests)
                        {
                            var scrollPosition = request.IsRelative ? _scrollOffsets - request.ScrollValue : -request.ScrollValue;
                            UpdateScrollOffsets(scrollPosition);
                        }
                    }
                    else
                    {
                        UpdateScrollOffsets(_scrollOffsets); // insures that scrolling is not out of bounds
                    }

                    // update the position of the child
                    UpdateVisualContentArrangeMatrix();
                }
            }

            _scrollingRequests.Clear();

            return finalSizeWithoutMargins;
        }

        private void StopScrolling()
        {
            HideScrollBars();
            StopCurrentScrolling();
        }

        private void SetUserManuallyScrolled()
        {
            _userManuallyScrolled = true;
            _rubberBandEasingOut = false;
        }

        private void UpdateScrollOffsetsAndContent(Vector3 desiredScrollPosition)
        {
            if (UpdateScrollOffsets(desiredScrollPosition))
            {
                UpdateVisualContentArrangeMatrix();
            }
        }

        private bool UpdateScrollOffsets(Vector3 desiredScrollPosition)
        {
            var offsets = _actualScrollOffsets;

            // update scroll viewer scroll offsets
            foreach (var index in _scrollModeToDirectionIndices)
            {
                float offset, minimumOffset;

                // update the scroll offset
                if (index == 0)
                {
                    offset = desiredScrollPosition.X;
                    minimumOffset = ViewPort.X - _contentRenderSizeWithPadding.X;
                }
                else
                {
                    offset = desiredScrollPosition.Y;
                    minimumOffset = ViewPort.Y - _contentRenderSizeWithPadding.Y;
                }

                if (_rubberBandEntered)
                {
                    var endRubberBand = (_rubberBandUpSpace && offset <= 0f) || (!_rubberBandUpSpace && offset >= 0f);
                    if (endRubberBand)
                    {
                        if (_rubberBandEasingOut)
                        {
                            _rubberBandEasingOut = false;
                            offset = _rubberBandStartOffset;
                            _currentScrollingSpeed[index] = 0f;
                        }
                        _rubberBandEntered = false;
                        if (_refreshInitiated)
                        {
                            _refreshInitiated = false;
                            EndRefresh();
                        }
                        UpdateScrollingBarsSize();
                    }
                }

                if (!_rubberBandEntered)
                {
                    var canScrollContent = minimumOffset < 0f;
                    // reached the offset limit?
                    var aboveLeftLimit = offset > 0f;
                    if (!canScrollContent || aboveLeftLimit || offset < minimumOffset)
                    {
                        var newOffset = aboveLeftLimit || !canScrollContent ? 0f : minimumOffset;
                        if (RubberBandEnabled && (IsUserScrollingViewer || _userManuallyScrolled))
                        {
                            _rubberBandEntered = true;
                            _rubberBandStartOffset = newOffset;
                            _rubberBandUpSpace = aboveLeftLimit;

                            if (_refreshRubberBandOffsetRequired == 0 && RefreshImage != null)
                            {
                                var size = RefreshImage.GetSprite().SizeInPixels;
                                _refreshRubberBandOffsetRequired = (_scrollMode == ScrollingMode2D.Horizontal ? size.X : size.Y) + RefreshImageMargin;
                            }
                        }
                        else
                        {
                            offset = newOffset;
                            _currentScrollingSpeed[index] = 0f;
                        }
                    }
                }

                if (index == 0)
                    _scrollOffsets.X = offset;
                else
                    _scrollOffsets.Y = offset;
            }

            _actualScrollOffsets = _scrollOffsets;

            if (_rubberBandEntered && !_rubberBandEasingOut)
            {
                foreach (var index in _scrollModeToDirectionIndices)
                {
                    // graph this out to see it, try https://www.desmos.com/calculator
                    // [ 50 * ln (x / 40 + 1) ]
                    // for an ideal height of 80 pixels, it is arrived at by 158 pixels of translation
                    float offset;
                    if (index == 0)
                    {
                        var n = Math.Abs(_actualScrollOffsets.X - _rubberBandStartOffset);
                        offset = (float)(50.0 * Math.Log(Math.Min(n, ViewPort.X) / 40.0 + 1.0));
                        if (!_rubberBandUpSpace)
                            offset = -offset;
                        _actualScrollOffsets.X = offset + _rubberBandStartOffset;
                    }
                    else
                    {
                        var n = Math.Abs(_actualScrollOffsets.Y - _rubberBandStartOffset);
                        offset = (float)(50.0 * Math.Log(Math.Min(n, ViewPort.Y) / 40.0 + 1.0));
                        if (!_rubberBandUpSpace)
                            offset = -offset;
                        _actualScrollOffsets.Y = offset + _rubberBandStartOffset;
                    }

                    // top-only event?
                    if (!_refreshInitiated && offset > _refreshRubberBandOffsetRequired)
                    {
                        _refreshInitiated = true;
                        HandleRefreshed();
                    }
                }
            }

            // round it to pixel accuracy to increase visual precision and reduce amount of rendering?
            foreach (var index in _scrollModeToDirectionIndices)
            {
                if (index == 0)
                    _actualScrollOffsets.X = (float)Math.Round(_actualScrollOffsets.X);
                else
                    _actualScrollOffsets.Y = (float)Math.Round(_actualScrollOffsets.Y);
            }

            if (offsets != _actualScrollOffsets)
            {
                if (_rubberBandEntered)
                {
                    UpdateScrollingBarsSize();
                }
                return true;
            }
            return false;
        }

        private void HandleRefreshed()
        {
            if (Refreshed != null)
            {
                var args = new CancelEventArgs();
                Refreshed.Invoke(this, args);
                if (args.Cancel)
                    return;
            }

            if (RefreshImage != null)
            {
                if (_refreshElement == null)
                {
                    _refreshElement = new AnimatedImageElement
                    {
                        Source = RefreshImage,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        VerticalAlignment = VerticalAlignment.Center,
                        Margin = Thickness.UniformRectangle(RefreshImageMargin)
                    };
                    _refreshElement.Measure(Vector3.Zero);
                    _refreshElement.Arrange(Vector3.Zero, false);
                    SetVisualParent(_refreshElement, this);
                    _refreshElement.SpriteChanged += OnRefreshElementSpriteChanged;
                }
                else
                {
                    _refreshElement.Visibility = Visibility.Visible;
                }
                foreach (var index in _scrollModeToDirectionIndices)
                    UpdateRefreshElementWorldMatrix(index);
            }
        }

        private void UpdateScrollingBarsSize()
        {
            _canScrollContent = false;

            // set the size of the bar we want to show
            foreach (var index in _scrollModeToDirectionIndices)
            {
                var scrollBar = _scrollBars[index];

                // reset the bar size
                scrollBar.Arrange(Vector3.Zero, false);

                float sizeChildren;
                float sizeViewPort;

                if (index == 0)
                {
                    sizeChildren = VisualContent.RenderSize.X + VisualContent.MarginInternal.Left + VisualContent.MarginInternal.Right;
                    sizeViewPort = ViewPort.X;
                }
                else
                {
                    sizeChildren = VisualContent.RenderSize.Y + VisualContent.MarginInternal.Top + VisualContent.MarginInternal.Bottom;
                    sizeViewPort = ViewPort.Y;
                }

                if (_rubberBandEntered)
                {
                    sizeViewPort -= Math.Abs(_actualScrollOffsets[index] - _rubberBandStartOffset);
                }
                var canScroll = sizeChildren > sizeViewPort;

                var barSize = Vector3.Zero;
                for (var dim = 0; dim < 3; dim++)
                {
                    float size;
                    if (dim == index)
                    {
                        if (canScroll)
                        {
                            _canScrollContent = true;
                            size = (sizeViewPort / sizeChildren) * sizeViewPort;
                        }
                        else
                        {
                            size = sizeViewPort;
                        }
                    }
                    else
                    {
                        size = Math.Min(ScrollBarThickness + scrollBar.Margin[dim + 3], ViewPort[dim]);
                    }
                    barSize[dim] = size;
                }

                scrollBar.Arrange(barSize, IsCollapsed);

                if (!ScrollBarHidesNoActivity)
                {
                    scrollBar.Visibility = canScroll ? Visibility.Visible : Visibility.Collapsed;
                }
            }
        }

        private void UpdateVisualContentArrangeMatrix()
        {
            // calculate the offsets to move the element of

            // compute the rendering offsets of the child element wrt the parent origin (0,0,0)
            var childOffsets = _actualScrollOffsets + new Vector3(Padding.Left, Padding.Top, Padding.Front) - ViewPort / 2;

            // set the arrange matrix of the child.
            VisualContent.DependencyProperties.Set(ContentArrangeMatrixPropertyKey, Matrix.Translation(childOffsets));

            // force re-calculation of main element and scroll bars world matrices
            ArrangeChanged = true;

            // redraw needed
            IsDirty = true;
        }

        protected override void UpdateWorldMatrix(ref Matrix parentWorldMatrix, bool parentWorldChanged)
        {
            var shouldUpdateScrollBars = parentWorldChanged || ArrangeChanged || LocalMatrixChanged;

            base.UpdateWorldMatrix(ref parentWorldMatrix, parentWorldChanged);

            // set the world matrices of the scroll bars
            if (shouldUpdateScrollBars && VisualContent != null)
            {
                foreach (var index in _scrollModeToDirectionIndices)
                {
                    var scrollBar = _scrollBars[index];
                    var barSize = CalculateSizeWithThickness(ref scrollBar.RenderSizeInternal, ref scrollBar.MarginInternal);
                    var barPosition = RenderSize / 2 - barSize;

                    // adjust the position of the scroll bar
                    var renderSize = RenderSize[index];
                    float pos;

                    // determine the position ratio of the scroll bar in the viewport
                    if (!_rubberBandEntered)
                    {
                        pos = renderSize / -2f;
                        if (index == 0)
                        {
                            var childMinusParent = VisualContent.DesiredSizeWithMargins.X - ViewPort.X;
                            if (childMinusParent > MathUtil.ZeroTolerance)
                            {
                                var scrollBarPositionRatio = _actualScrollOffsets.X / childMinusParent;
                                pos -= scrollBarPositionRatio * (renderSize - scrollBar.RenderSize.X);
                            }
                        }
                        else
                        {
                            var childMinusParent = VisualContent.DesiredSizeWithMargins.Y - ViewPort.Y;
                            if (childMinusParent > MathUtil.ZeroTolerance)
                            {
                                var scrollBarPositionRatio = _actualScrollOffsets.Y / childMinusParent;
                                pos -= scrollBarPositionRatio * (renderSize - scrollBar.RenderSize.Y);
                            }
                        }
                    }
                    else
                    {
                        if (_rubberBandUpSpace)
                        {
                            pos = renderSize / -2f;
                        }
                        else
                        {
                            // lock the scrollbar at right/bottom extremity
                            pos = renderSize / 2f - scrollBar.RenderSize[index];
                        }
                    }

                    barPosition[index] = pos;

                    var parentMatrix = WorldMatrix;
                    parentMatrix.TranslationVector += barPosition;

                    ((IUIElementUpdate)scrollBar).UpdateWorldMatrix(ref parentMatrix, true);

                    if (_refreshElement != null && _refreshElement.IsVisible)
                    {
                        UpdateRefreshElementWorldMatrix(index);
                    }
                }
            }
        }

        private void UpdateRefreshElementWorldMatrix(int index)
        {
            var elemSize = CalculateSizeWithThickness(ref _refreshElement.RenderSizeInternal, ref _refreshElement.MarginInternal);
            var elemPosition = Vector3.Zero;
            if (index == 0)
                elemPosition.X = (VisualContent.RenderSize.X + elemSize.X) / -2f;
            else
                elemPosition.Y = (VisualContent.RenderSize.Y + elemSize.Y) / -2f;

            var parentMatrix = VisualContent.WorldMatrix;
            parentMatrix.TranslationVector += elemPosition;

            ((IUIElementUpdate)_refreshElement).UpdateWorldMatrix(ref parentMatrix, true);
        }

        protected override void OnPreviewTouchDown(TouchEventArgs args)
        {
            base.OnPreviewTouchDown(args);

            if (!_canScrollContent && !RubberBandEnabled)
                return;

            StopCurrentScrolling();
            IsTouchedDown = true;
            _accumulatedTouchTranslation = Vector3.Zero;
        }

        protected override void OnPreviewTouchUp(TouchEventArgs args)
        {
            base.OnPreviewTouchUp(args);

            if (IsUserScrollingViewer)
            {
                args.Handled = true;

                // need a copy since args.IsBeingRouted is true
                var argsCopy = new TouchEventArgs
                {
                    Action = args.Action,
                    ScreenPosition = args.ScreenPosition,
                    ScreenTranslation = args.ScreenTranslation,
                    Timestamp = args.Timestamp
                };
                RaiseLeaveTouchEventToHierarchyChildren(this, argsCopy);

                IsUserScrollingViewer = false;
            }

            IsTouchedDown = false;
            _accumulatedTouchTranslation = Vector3.Zero;
        }

        protected override void OnTouchEnter(TouchEventArgs args)
        {
            base.OnTouchEnter(args);

            StopCurrentScrolling();
            _accumulatedTouchTranslation = Vector3.Zero;
        }

        protected override void OnTouchLeave(TouchEventArgs args)
        {
            base.OnTouchLeave(args);

            IsUserScrollingViewer = false;
            IsTouchedDown = false;
            _accumulatedTouchTranslation = Vector3.Zero;
        }

        protected override void OnPreviewTouchMove(TouchEventArgs args)
        {
            base.OnPreviewTouchMove(args);

            if (!IsTouchedDown || ScrollMode == ScrollingMode2D.None || !TouchScrollingEnabled)
                return;

            // accumulate all the touch moves of the frame
            var translation = args.WorldTranslation;
            foreach (var index in _scrollModeToDirectionIndices)
            {
                if (index == 0)
                    _accumulatedTouchTranslation.X -= translation.X;
                else
                    _accumulatedTouchTranslation.Y -= translation.Y;
            }

            if (!IsUserScrollingViewer)
            {
                if (_accumulatedTouchTranslation.Length() > ScrollStartThreshold)
                {
                    IsUserScrollingViewer = true;
                    _rubberBandEasingOut = false;

                    // start scrolling from this point - avoids 'jump' after threshold reached
                    _accumulatedTouchTranslation = Vector3.Zero;
                }
            }

            if (IsUserScrollingViewer)
                args.Handled = true;
        }

        private static void RaiseLeaveTouchEventToHierarchyChildren(UIElement parent, TouchEventArgs args)
        {
            if (parent == null)
                return;

            foreach (var child in parent.VisualChildrenCollection)
            {
                if (child.IsTouched)
                {
                    child.RaiseTouchLeaveEvent(args);
                    RaiseLeaveTouchEventToHierarchyChildren(child, args);
                }
            }
        }
    }
}
