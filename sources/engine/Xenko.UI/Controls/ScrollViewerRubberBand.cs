// Copyright (c) Xenko contributors (https://xenko.com) and Silicon Studio Corp. (https://www.siliconstudio.co.jp)
// Distributed under the MIT license. See the LICENSE.md file in the project root for more information.
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;

using Xenko.Core;
using Xenko.Core.Annotations;
using Xenko.Core.Mathematics;
using Xenko.Engine;
using Xenko.Games;

namespace Xenko.UI.Controls
{
    /// <summary>
    /// Represents a scroll viewer with rubberband. 
    /// A scroll viewer element has an infinite virtual size defined by its <see cref="ScrollingMode"/>.
    /// The user can move in that virtual size by touching and panning on the screen.
    /// </summary>
    [DataContract(nameof(ScrollViewerRubberBand))]
    [CategoryOrder(40, ScrollBarCategory, Expand = ExpandRule.Auto)]
    [CategoryOrder(50, RefreshCategory, Expand = ExpandRule.Auto)]
    [DebuggerDisplay("ScrollViewerRubberBand - Name={Name}")]
    public class ScrollViewerRubberBand : ContentControl
    {
        private const string ScrollBarCategory = "ScrollBar";
        private const string RefreshCategory = "Refresh";

        private static readonly Dictionary<ScrollingMode, int[]> ScrollModeToDirectionIndicesMap = new Dictionary<ScrollingMode, int[]>
        {
            { ScrollingMode.None, new int[0] },
            { ScrollingMode.Horizontal, new[] { 0 } },
            { ScrollingMode.Vertical, new[] { 1 } },
            { ScrollingMode.HorizontalVertical, new[] { 0, 1 } },
        };

        /// <summary>
        /// The current offsets (in virtual pixels) generated by the scrolling on the <see cref="ContentControl.Content"/> element.
        /// </summary>
        private Vector2 _scrollOffsets;
        private Vector2 _actualScrollOffsets;

        /// <summary>
        /// The current speed of the scrolling in virtual pixels.
        /// </summary>
        private Vector2 _currentScrollingSpeed;

        /// <summary>
        /// True if any direction of the content can be scrolled.
        /// </summary>
        private bool _canScrollContent;

        private ScrollingMode _scrollMode = ScrollingMode.Vertical;
        private int[] _scrollModeToDirectionIndices = ScrollModeToDirectionIndicesMap[ScrollingMode.Vertical];
        private Color _scrollBarColor = new Color(96, 96, 96);
        private ISpriteProvider _scrollBarThumbImage;
        private bool _touchScrollingEnabled = true;
        private bool _isTouchedDown;
        private bool _isUserScrollingViewer;
        private bool _userManuallyScrolled;
        private bool _delayedManuallyScrolled;
        private float _deceleration = 2500.0f;
        private Vector2 _accumulatedTouchTranslation;
        private Vector2 _contentRenderSizeWithoutPadding;
        private Vector2 _accumulatedDelayedTranslation;
        private Vector2 _previousAccumulatedDelayedTranslation;
        private Vector2 _actualViewPort;

        private bool _rubberBandEntered;
        private bool _rubberBandEasingOut;
        private bool _rubberBandUpSpace;
        private float _rubberBandStartOffset;

        private ISpriteProvider _refreshImage;
        private Vector3 _refreshImageTextureOffset;
        private Thickness _refreshImageMargin = new Thickness(3);
        private AnimatedImageElement _refreshElement;
        private Border _refreshBkgdElement;
        private Color _refreshBkgdColor = new Color(16, 16, 16);
        private float _refreshShowOffsetRequired;
        private float _refreshFrameDistanceRatio;
        private bool _isRefreshEnabled = true;
        private bool _isRefreshing;
        private bool _refreshingInitiated;
        private bool _refreshElementFixedAtTop;

        private readonly ScrollBar[] _scrollBars =
        {
            new ScrollBar { Name = "Left/Right SB", Margin = new Thickness(0, 0, 0, 2), Visibility = Visibility.Collapsed, RotateThumbImage = true },
            new ScrollBar { Name = "Top/Bottom SB", Margin = new Thickness(0, 0, 2, 0), Visibility = Visibility.Collapsed },
        };

        private struct ScrollRequest
        {
            public Vector2 ScrollValue;
            public bool IsRelative;
        }

        /// <summary>
        /// The list of scrolling requests that need to be performed during the next <see cref="ArrangeOverride"/>
        /// </summary>
        private readonly List<ScrollRequest> _scrollingRequests = new List<ScrollRequest>();

        public event EventHandler IsUserScrollingViewerChanged;

        public event EventHandler Refreshing;
        public event EventHandler Refresh;

        public ScrollViewerRubberBand()
        {
            // put the scroll bars above the presenter and add them to the grid canvas
            foreach (var scrollBar in _scrollBars)
            {
                scrollBar.BarColorInternal = ScrollBarColor;
                scrollBar.Measure(Vector2.Zero); // set is measure valid to true
                SetVisualParent(scrollBar, this);
            }

            CanBeHitByUser = _touchScrollingEnabled;
            ClipToBounds = true;
        }

        /// <summary>
        /// Indicate if the user is currently touching the scroll viewer and performing a scroll gesture with its finger.
        /// </summary>
        public bool IsUserScrollingViewer
        {
            get { return _isUserScrollingViewer; }
            private set
            {
                if (_isUserScrollingViewer == value)
                    return;

                _isUserScrollingViewer = value;
                OnIsUserScrollingViewerChanged();
            }
        }

        public Vector2 ActualScrollOffsets
        {
            get { return _actualScrollOffsets; }
        }

        /// <summary>
        /// The viewport of the <see cref="ScrollViewer"/> in virtual pixels.
        /// </summary>
        public Vector2 ViewPort { get; private set; }

        /// <summary>
        /// Gets or sets the color of the scrolling bar.
        /// </summary>
        /// <userdoc>The color of the scrolling bar.</userdoc>
        [DataMember]
        [Display(category: ScrollBarCategory)]
        public Color ScrollBarColor
        {
            get { return _scrollBarColor; }
            set
            {
                if (_scrollBarColor == value)
                    return;

                _scrollBarColor = value;
                foreach (var scrollBar in _scrollBars)
                    scrollBar.BarColorInternal = value;
            }
        }

        /// <summary>
        /// Gets or sets the scrolling bar thickness in virtual pixels.
        /// </summary>
        /// <userdoc>The scrolling bar thickness in virtual pixels.</userdoc>
        [DataMember]
        [Display(category: ScrollBarCategory)]
        [DefaultValue(6.0f)]
        public float ScrollBarThickness { get; set; } = 6.0f;

        /// <summary>
        /// Indicate if the scrollbar fades out after scrolling stops.
        /// </summary>
        /// <userdoc>True if scrollbar fades out after scrolling stops.</userdoc>
        [DataMember]
        [Display(category: ScrollBarCategory)]
        [DefaultValue(false)]
        public bool ScrollBarHidesNoActivity { get; set; }

        /// <summary>
        /// Gets or sets the image to display as slider thumb.
        /// </summary>
        /// <userdoc>The image to display as slider thumb.</userdoc>
        [DataMember]
        [Display(category: ScrollBarCategory)]
        [DefaultValue(null)]
        public ISpriteProvider ScrollBarThumbImage
        {
            get { return _scrollBarThumbImage; }
            set
            {
                _scrollBarThumbImage = value;
                foreach (var scrollBar in _scrollBars)
                    scrollBar.ThumbImage = value;
            }
        }

        /// <summary>
        /// The viewer allowed scrolling mode.
        /// </summary>
        /// <userdoc>The viewer allowed scrolling mode.</userdoc>
        [DataMember]
        [Display(category: BehaviorCategory)]
        [DefaultValue(ScrollingMode.Vertical)]
        public ScrollingMode ScrollMode
        {
            get { return _scrollMode; }
            set
            {
                if (_scrollMode == value)
                    return;

                _scrollMode = value;

                _scrollModeToDirectionIndices = ScrollModeToDirectionIndicesMap[_scrollMode];
                _actualScrollOffsets = _scrollOffsets = Vector2.Zero;
                InvalidateMeasure();
            }
        }

        /// <summary>
        /// Gets or sets the threshold distance over which a touch move starts scrolling.
        /// </summary>
        /// <userdoc>The threshold distance over which a touch move starts scrolling.</userdoc>
        [DataMember]
        [Display(category: BehaviorCategory)]
        [DefaultValue(25.0f)]
        public float ScrollStartThreshold { get; set; } = 25.0f;

        /// <summary>
        /// The automatic deceleration of the scroll after the user remove its finger from the screen. The unit is in virtual pixels.
        /// </summary>
        /// <userdoc>The automatic deceleration of the scroll after the user remove its finger from the screen. The unit is in virtual pixels.</userdoc>
        [DataMember]
        [Display(category: BehaviorCategory)]
        [DefaultValue(2500.0f)]
        public float Deceleration
        {
            get { return _deceleration; }
            set
            {
                if (float.IsNaN(value))
                    return;
                _deceleration = value;
            }
        }

        /// <summary>
        /// Gets or sets the value indicating if rubber banding should be enabled.
        /// </summary>
        [DataMember]
        [Display(category: BehaviorCategory)]
        [DefaultValue(true)]
        public bool IsRubberBandEnabled { get; set; } = true;

        /// <summary>
        /// Gets or sets the scrolling behavior on touches. True to allow the user to scroll by touching, false to forbid it.
        /// </summary>
        /// <userdoc>True to allow the user to scroll by touching, false to forbid it.</userdoc>
        [DataMember]
        [Display(category: BehaviorCategory)]
        [DefaultValue(true)]
        public bool TouchScrollingEnabled
        {
            get { return _touchScrollingEnabled; }
            set
            {
                if (_touchScrollingEnabled == value)
                    return;

                _touchScrollingEnabled = value;
                CanBeHitByUser = value;
            }
        }

        /// <summary>
        /// Gets or sets the value indicating if refresh should be enabled.
        /// </summary>
        [DataMember]
        [Display(category: RefreshCategory)]
        [DefaultValue(true)]
        public bool IsRefreshEnabled
        {
            get { return _isRefreshEnabled; }
            set
            {
                _isRefreshEnabled = value;
                if (!value)
                    IsRefreshing = false;
            }
        }

        /// <summary>
        /// Gets or sets the refresh animation sprite sheet to display in top or left rubberband empty area.
        /// </summary>
        /// <userdoc>The image to display as refresh animation.</userdoc>
        [DataMember]
        [Display(category: RefreshCategory)]
        [DefaultValue(null)]
        public ISpriteProvider RefreshImage
        {
            get { return _refreshImage; }
            set
            {
                _refreshImage = value;

                if (_refreshElement != null)
                    UpdateRefreshElement();
            }
        }

        /// <summary>
        /// Background color of the refresh bar, shown when it is refreshing.
        /// </summary>
        [DataMember]
        [Display(category: RefreshCategory)]
        public Color RefreshBackgroundColor
        {
            get { return _refreshBkgdColor; }
            set
            {
                _refreshBkgdColor = value;
                if (_refreshBkgdElement != null)
                {
                    _refreshBkgdElement.BackgroundColor = _refreshBkgdColor;
                }
            }
        }

        [DataMember]
        [Display(category: RefreshCategory)]
        public Thickness RefreshImageMargin
        {
            get { return _refreshImageMargin; }
            set
            {
                _refreshImageMargin = value;

                if (_refreshElement != null)
                    UpdateRefreshElement();
            }
        }

        /// <summary>
        /// The pull down offset required to raise the Refreshing event.
        /// </summary>
        [DataMember]
        [Display(category: RefreshCategory)]
        [DefaultValue(70f)]
        public float RefreshingOffsetRequired { get; set; } = 70f;

        /// <summary>
        /// A factor to adjust the current Refresh image frame per distance pulled. A smaller number would slow it down.
        /// </summary>
        [DataMember]
        [Display(category: RefreshCategory)]
        [DefaultValue(1f)]
        public float RefreshFrameDistanceFactor { get; set; } = 1f;

        [DataMemberIgnore]
        public bool IsRefreshing
        {
            get { return _isRefreshing; }
            set
            {
                if (value == _isRefreshing)
                    return;
                _isRefreshing = value;
                OnIsRefreshingChanged();
            }
        }

        public override UIElement Content
        {
            get { return base.Content; }
            set
            {
                if (base.Content == value)
                    return;

                base.Content = value;

                // reset the current scrolling cache data
                StopScrolling();
                _actualScrollOffsets = _scrollOffsets = Vector2.Zero;

                VisualChildrenCollection.Sort(ScrollBarSorter.Instance);
            }
        }

        public override bool IsEnabled
        {
            set
            {
                if (!value)
                {
                    HideScrollBars();
                }

                base.IsEnabled = value;
            }
        }

        /// <summary>
        /// Indicate if the scroll viewer can scroll in the given direction.
        /// </summary>
        /// <param name="direction">The direction to use for the test</param>
        /// <returns><value>true</value> if the scroll viewer can scroll in the provided direction, or else <value>false</value></returns>
        public bool CanScroll(Orientation direction)
        {
            return ((int)_scrollMode) - 1 == (int)direction || _scrollMode == ScrollingMode.HorizontalVertical;
        }

        protected virtual void OnIsUserScrollingViewerChanged()
        {
            IsUserScrollingViewerChanged?.Invoke(this, EventArgs.Empty);
        }

        protected override void Update(GameTime time)
        {
            base.Update(time);

            if (!IsEnabled)
                return;

            var frameElapsedSeconds = (float)time.Elapsed.TotalSeconds;
            if (frameElapsedSeconds < MathUtil.ZeroTolerance)
                return;

            UpdateScrolling(frameElapsedSeconds);

            if (ScrollBarHidesNoActivity)
            {
                // Smoothly hide the scroll bars if the no movements
                foreach (var index in _scrollModeToDirectionIndices)
                {
                    var scrollBar = _scrollBars[index];
                    var speed = index == 0 ? _currentScrollingSpeed.X : _currentScrollingSpeed.Y;
                    var shouldFadeOutScrollingBar = MathUtil.IsZero(speed) && (!TouchScrollingEnabled || !IsUserScrollingViewer);
                    if (shouldFadeOutScrollingBar)
                    {
                        if (scrollBar.BarColorInternal.A != 0)
                        {
                            scrollBar.BarColorInternal.A = (byte)Math.Max(0, scrollBar.BarColorInternal.A - ScrollBarColor.A * frameElapsedSeconds);
                            if (scrollBar.BarColorInternal.A == 0)
                            {
                                scrollBar.Visibility = Visibility.Collapsed;
                            }
                            // redraw needed
                            scrollBar.IsDirty = true;
                        }
                    }
                    else
                    {
                        if (!scrollBar.IsVisible)
                        {
                            scrollBar.Visibility = Visibility.Visible;
                            scrollBar.BarColorInternal = ScrollBarColor;
                        }
                    }
                }
            }
        }

        private void UpdateScrolling(float frameElapsedSeconds)
        {
            if (_userManuallyScrolled)
            {
                foreach (var index in _scrollModeToDirectionIndices)
                {
                    if (index == 0)
                    {
                    }
                    else
                    {
                        if (_accumulatedDelayedTranslation.Y != 0)
                        {
                            if (Math.Sign(_previousAccumulatedDelayedTranslation.Y) != Math.Sign(_accumulatedDelayedTranslation.Y))
                            {
                                // user flipped direction from + to - (or vice-versa) on thumbstick
                                // so there's no delay when easing out
                                _scrollOffsets = _actualScrollOffsets;
                            }

                            _delayedManuallyScrolled = true;
                            ScrollOfInternal(ref _accumulatedDelayedTranslation, false);
                            _delayedManuallyScrolled = false;

                            _previousAccumulatedDelayedTranslation = _accumulatedDelayedTranslation;
                            _accumulatedDelayedTranslation = Vector2.Zero;
                        }
                        else
                        {
                            // so there's no delay when easing out
                            _scrollOffsets = _actualScrollOffsets;
                            _previousAccumulatedDelayedTranslation = _accumulatedDelayedTranslation;
                        }
                    }
                }

                _userManuallyScrolled = false;
                return;
            }

            Vector2 scrollTranslation;

            if (IsUserScrollingViewer)
            {
                // nothing to do if no translation
                var noTranslation = true;
                foreach (var index in _scrollModeToDirectionIndices)
                {
                    // the touch system probably doesn't have a resolution that can give deltas in very small values
                    // in most cases this is a test for 'not zero', but I wanted something a little bigger than Epsilon, in case,
                    // eg. user holds controller ray on one spot but it "very slightly moves", which gives tiny translation 'noise'
                    var v = index == 0 ? _accumulatedTouchTranslation.X : _accumulatedTouchTranslation.Y;
                    if (Math.Abs(v) >= 0.2f)
                    {
                        noTranslation = false;
                        break;
                    }
                }
                if (noTranslation)
                    return;

                scrollTranslation = _accumulatedTouchTranslation;
                _accumulatedTouchTranslation = Vector2.Zero;

                // compute the scrolling speed based on current translation
                _currentScrollingSpeed = scrollTranslation / frameElapsedSeconds;
            }
            else // scrolling is free: compute the scrolling translation based on the scrolling speed and anchors
            {
                if (_rubberBandEntered)
                {
                    // ease out back to zero, like the anchor snapping effect below
                    if (!_rubberBandEasingOut)
                    {
                        _rubberBandEasingOut = true;
                        _scrollOffsets = _actualScrollOffsets;
                        StopCurrentScrolling();

                        // raise Refresh event if released and still beyond refreshing offset
                        if (_refreshingInitiated && _isRefreshEnabled && !IsRefreshing)
                        {
                            foreach (var index in _scrollModeToDirectionIndices)
                            {
                                if (_scrollOffsets[index] >= RefreshingOffsetRequired)
                                {
                                    Refresh?.Invoke(this, EventArgs.Empty);
                                }
                            }
                        }
                    }

                    scrollTranslation = Vector2.Zero;
                    foreach (var index in _scrollModeToDirectionIndices)
                    {
                        var offset = Math.Abs((index == 0 ? _scrollOffsets.X : _scrollOffsets.Y) - _rubberBandStartOffset);
                        var d = 10f * offset * frameElapsedSeconds;
                        if (offset - d < 1f)
                        {
                            d = offset;
                        }
                        if (!_rubberBandUpSpace)
                            d = -d;
                        if (index == 0)
                            scrollTranslation.X = d;
                        else
                            scrollTranslation.Y = d;
                    }

                    ScrollOfInternal(ref scrollTranslation, false);
                    return;
                }

                // nothing to do if no scrolling speed
                var noSpeed = true;
                foreach (var index in _scrollModeToDirectionIndices)
                {
                    var speed = index == 0 ? _currentScrollingSpeed.X : _currentScrollingSpeed.Y;
                    if (!MathUtil.IsZero(speed))
                    {
                        noSpeed = false;
                        break;
                    }
                }
                if (noSpeed)
                    return;

                scrollTranslation = _currentScrollingSpeed * frameElapsedSeconds;
            }

            // decrease the scrolling speed used for next frame
            var decrease = Deceleration * frameElapsedSeconds;
            foreach (var index in _scrollModeToDirectionIndices)
            {
                var speed = index == 0 ? _currentScrollingSpeed.X : _currentScrollingSpeed.Y;
                if (speed != 0f)
                {
                    var newSpeed = Math.Abs(speed) - decrease;
                    if (newSpeed > 0f)
                        newSpeed = Math.Sign(speed) * newSpeed;
                    else
                        newSpeed = 0f;
                    if (index == 0)
                        _currentScrollingSpeed.X = newSpeed;
                    else
                        _currentScrollingSpeed.Y = newSpeed;
                }
            }

            // update the scrolling position
            if (scrollTranslation != Vector2.Zero)
                ScrollOfInternal(ref scrollTranslation, false);
        }

        /// <summary>
        /// Go to the beginning of the scroll viewer's content in the provided direction.
        /// </summary>
        /// <param name="direction">The direction in which to scroll</param>
        /// <param name="stopScrolling">Indicate if the scrolling should be stopped after the scroll action.</param>
        public void ScrollToBeginning(Orientation direction, bool stopScrolling = true)
        {
            ScrollToExtremity(direction, stopScrolling, true);
        }

        /// <summary>
        /// Go to the end of the scroll viewer's content in the provided direction.
        /// </summary>
        /// <param name="direction">The direction in which to scroll</param>
        /// <param name="stopScrolling">Indicate if the scrolling should be stopped after the scroll action.</param>
        public void ScrollToEnd(Orientation direction, bool stopScrolling = true)
        {
            ScrollToExtremity(direction, stopScrolling, false);
        }

        private void ScrollToExtremity(Orientation direction, bool stopScrolling, bool isBeginning)
        {
            if (stopScrolling)
            {
                StopScrolling();
            }

            if (VisualContent == null || !CanScroll(direction))
                return;

            var position = Vector2.Zero;
            if (!isBeginning)
            {
                if (direction == Orientation.Horizontal)
                    position.X = _actualViewPort.X - _contentRenderSizeWithoutPadding.X;
                else
                    position.Y = _actualViewPort.Y - _contentRenderSizeWithoutPadding.Y;
            }
            ScrollTo(position, false);
        }

        /// <summary>
        /// Try to scroll to the provided position (in virtual pixels). 
        /// If the provided translation is too important, it is clamped.
        /// </summary>
        /// <remarks>Note that the computational cost of <see cref="ScrollTo"/> can be greatly higher than <see cref="ScrollOf"/> 
        /// when scrolling is delegated to a <see cref="Content"/> virtualizing its items. When possible, prefer call to <see cref="ScrollOf"/></remarks>
        /// <param name="scrollAbsolutePosition">The scroll offsets to apply</param>
        /// <param name="stopScrolling">Indicate if the scrolling should be stopped after the scroll action.</param>
        public void ScrollTo(Vector2 scrollAbsolutePosition, bool stopScrolling = true)
        {
            if (stopScrolling)
            {
                StopScrolling();
            }

            if (VisualContent == null)
                return;

            SetUserManuallyScrolled();

            if (IsArrangeValid) // the children size informations are still valid -> perform scrolling right away
            {
                UpdateScrollOffsetsAndContent(-scrollAbsolutePosition);
            }
            else // children may have changed of size -> delay scrolling to next draw call
            {
                InvalidateArrange(); // force next arrange to perform scrolls
                _scrollingRequests.Clear(); // optimization remove previous request when provided position is absolute
                _scrollingRequests.Add(new ScrollRequest { ScrollValue = scrollAbsolutePosition });
            }
        }

        /// <summary>
        /// Try to scroll of the provided scrolling translation value from the current position. 
        /// If the provided translation is too important, it is clamped.
        /// </summary>
        /// <param name="scrollTranslation">The scroll translation to perform (in virtual pixels)</param>
        /// <param name="stopScrolling">Indicate if the scrolling should be stopped after the scroll action.</param>
        /// <param name="delayToUpdate">Indicate if the scroll action should occur in the Update call.</param>
        public void ScrollOf(Vector2 scrollTranslation, bool stopScrolling = true, bool delayToUpdate = false)
        {
            SetUserManuallyScrolled();

            if (delayToUpdate)
            {
                if (stopScrolling)
                {
                    StopScrolling();
                }

                // ScrollOfInternal can set ArrangeChanged to true, which puts it out sync with rendering (causes a wobble in scrollbar)
                // delaying the actual call to within the Update call fixes that all up
                _accumulatedDelayedTranslation += scrollTranslation;
            }
            else
            {
                ScrollOfInternal(ref scrollTranslation, stopScrolling);
            }
        }

        private void ScrollOfInternal(ref Vector2 scrollTranslation, bool stopScrolling)
        {
            if (stopScrolling)
            {
                StopScrolling();
            }

            if (VisualContent == null)
                return;

            if (IsArrangeValid) // the children size informations are still valid -> perform scrolling right away
            {
                UpdateScrollOffsetsAndContent(_scrollOffsets - scrollTranslation);
            }
            else // children may have changed of size -> delay scrolling to next draw call
            {
                InvalidateArrange(); // force next arrange to perform scrolls
                _scrollingRequests.Add(new ScrollRequest { IsRelative = true, ScrollValue = scrollTranslation });
            }
        }

        protected override Vector2 MeasureOverride(ref Vector2 availableSizeWithoutMargins)
        {
            // measure size desired by the children
            var childDesiredSizeWithMargins = Vector2.Zero;
            if (VisualContent != null)
            {
                // remove space for padding in availableSizeWithoutMargins
                var childAvailableSizeWithoutPadding = CalculateSizeWithoutThickness(ref availableSizeWithoutMargins, ref padding);

                // if the content is not scrollable perform space virtualization from the scroll viewer side.
                foreach (var index in _scrollModeToDirectionIndices)
                {
                    if (index == 0)
                        childAvailableSizeWithoutPadding.X = float.PositiveInfinity;
                    else
                        childAvailableSizeWithoutPadding.Y = float.PositiveInfinity;
                }

                VisualContent.Measure(ref childAvailableSizeWithoutPadding);
                childDesiredSizeWithMargins = VisualContent.DesiredSizeWithMargins;
            }

            // add the padding to the child desired size
            var desiredSizeWithPadding = CalculateSizeWithThickness(ref childDesiredSizeWithMargins, ref padding);
            return desiredSizeWithPadding;
        }

        protected override Vector2 ArrangeOverride(ref Vector2 finalSizeWithoutMargins)
        {
            _actualViewPort = finalSizeWithoutMargins;

            var viewport = finalSizeWithoutMargins;
            if (IsRefreshing)
            {
                // remove the space of the refresh band
                foreach (var index in _scrollModeToDirectionIndices)
                {
                    if (index == 0)
                        viewport.X -= _refreshBkgdElement.Width;
                    else
                        viewport.Y -= _refreshBkgdElement.Height;
                }
            }

            // calculate the remaining space for the child after having removed the padding space.
            ViewPort = viewport;

            // arrange the content
            if (VisualContent != null)
            {
                // calculate the final size given to the child (scroll view virtual size)
                var childSizeWithoutPadding = CalculateSizeWithoutThickness(ref viewport, ref padding);
                foreach (var index in _scrollModeToDirectionIndices)
                {
                    if (index == 0)
                        childSizeWithoutPadding.X = Math.Max(VisualContent.DesiredSizeWithMargins.X, childSizeWithoutPadding.X);
                    else
                        childSizeWithoutPadding.Y = Math.Max(VisualContent.DesiredSizeWithMargins.Y, childSizeWithoutPadding.Y);
                }

                // arrange the child
                VisualContent.Arrange(ref childSizeWithoutPadding, IsCollapsed);

                // the space desired by the child + the padding of the viewer
                var contentRenderSize = (Vector2)VisualContent.RenderSize;
                var contentRenderSizeWithoutMargins = CalculateSizeWithoutThickness(ref contentRenderSize, ref MarginInternal);
                _contentRenderSizeWithoutPadding = CalculateSizeWithoutThickness(ref contentRenderSizeWithoutMargins, ref padding);

                // if I'm currently easing out the rubberband space, I don't want to affect the scroll offsets in case an Arrange pass occurs
                // this is a problem because the scrolling is running freely, not user controlled, and inside UpdateScrollOffsets, it will force the offset to 0
                if (!_rubberBandEasingOut)
                {
                    // update the scrolling bars
                    UpdateScrollingBarsSize();

                    // update the scrolling
                    if (_scrollingRequests.Count > 0)
                    {
                        // perform the scrolling requests
                        foreach (var request in _scrollingRequests)
                        {
                            var scrollPosition = request.IsRelative ? _scrollOffsets - request.ScrollValue : -request.ScrollValue;
                            UpdateScrollOffsets(scrollPosition);
                        }
                    }
                    else
                    {
                        UpdateScrollOffsets(_scrollOffsets); // insures that scrolling is not out of bounds
                    }

                    // update the position of the child
                    UpdateVisualContentArrangeMatrix();
                }
            }

            _scrollingRequests.Clear();

            return finalSizeWithoutMargins;
        }

        private void StopCurrentScrolling()
        {
            _currentScrollingSpeed = Vector2.Zero;
        }

        private void StopScrolling()
        {
            HideScrollBars();
            StopCurrentScrolling();
        }

        private void HideScrollBars()
        {
            if (ScrollBarHidesNoActivity)
            {
                foreach (var index in _scrollModeToDirectionIndices)
                {
                    _scrollBars[index].Visibility = Visibility.Collapsed;
                }
            }
        }

        private void SetUserManuallyScrolled()
        {
            _userManuallyScrolled = true;
            _rubberBandEasingOut = false;
        }

        private void UpdateScrollOffsetsAndContent(Vector2 desiredScrollPosition)
        {
            if (UpdateScrollOffsets(desiredScrollPosition))
            {
                UpdateVisualContentArrangeMatrix();
            }
        }

        private bool UpdateScrollOffsets(Vector2 desiredScrollPosition)
        {
            var startScrollOffsets = _actualScrollOffsets;

            var topOffset = IsRefreshing ? _refreshShowOffsetRequired : 0f;

            // update scroll viewer scroll offsets
            foreach (var index in _scrollModeToDirectionIndices)
            {
                float offset, minimumOffset;

                // update the scroll offset
                if (index == 0)
                {
                    offset = desiredScrollPosition.X;
                    minimumOffset = ViewPort.X - _contentRenderSizeWithoutPadding.X;
                }
                else
                {
                    offset = desiredScrollPosition.Y;
                    minimumOffset = ViewPort.Y - _contentRenderSizeWithoutPadding.Y;
                }
                var canScrollContent = minimumOffset < 0f;

                if (_rubberBandEntered)
                {
                    bool endRubberBand = false;
                    if (_rubberBandUpSpace)
                    {
                        if (offset <= _rubberBandStartOffset)
                            endRubberBand = true;
                        else if (_rubberBandEasingOut && _refreshElement != null && _refreshElement.IsVisible && !IsRefreshing && offset < _refreshShowOffsetRequired)
                            ShowRefreshElement(false);
                    }
                    else
                    {
                        if (offset >= _rubberBandStartOffset)
                            endRubberBand = true;
                    }
                    if (endRubberBand)
                    {
                        if (_rubberBandEasingOut)
                        {
                            _rubberBandEasingOut = false;
                            if (IsRefreshing)
                                _refreshElementFixedAtTop = true;
                            offset = _rubberBandStartOffset;
                            _currentScrollingSpeed[index] = 0f;
                        }
                        _rubberBandEntered = false;

                        UpdateScrollingBarsSize();
                    }
                }

                if (!_rubberBandEntered)
                {
                    // be careful when canScrollContent is false and ScrollTo is called (absolute scroll)
                    // this code is also used to constain scroll within limits, but not necessarily enter a rubberband pull

                    var isUserScrolling = IsUserScrollingViewer || _delayedManuallyScrolled;

                    // reached the offset limit?
                    var aboveLeftLimit = offset > topOffset;
                    if ((!canScrollContent && isUserScrolling) || aboveLeftLimit || offset < minimumOffset + topOffset)
                    {
                        var newOffset = (aboveLeftLimit || !canScrollContent ? 0f : minimumOffset) + topOffset;
                        if (IsRubberBandEnabled && isUserScrolling)
                        {
                            _rubberBandEntered = true;
                            _rubberBandStartOffset = newOffset;
                            _rubberBandUpSpace = aboveLeftLimit;

                            if (aboveLeftLimit)
                            {
                                InitializeRefresh();
                            }
                        }
                        else
                        {
                            offset = newOffset;
                            _currentScrollingSpeed[index] = 0f;
                        }
                    }
                }

                if (index == 0)
                    _scrollOffsets.X = offset;
                else
                    _scrollOffsets.Y = offset;
            }

            _actualScrollOffsets = _scrollOffsets;

            if (_rubberBandEntered && !_rubberBandEasingOut)
            {
                foreach (var index in _scrollModeToDirectionIndices)
                {
                    float offset;
                    if (index == 0)
                    {
                        var n = Math.Abs(_actualScrollOffsets.X - _rubberBandStartOffset);
                        n = Math.Min(n, ViewPort.X); // the thumbstick can generate very high values, clamp it
                        offset = CalcRubberBandOffset(n);
                        _actualScrollOffsets.X = offset + _rubberBandStartOffset;
                    }
                    else
                    {
                        var n = Math.Abs(_actualScrollOffsets.Y - _rubberBandStartOffset);
                        n = Math.Min(n, ViewPort.Y); // the thumbstick can generate very high values, clamp it
                        offset = CalcRubberBandOffset(n);
                        _actualScrollOffsets.Y = offset + _rubberBandStartOffset;
                    }

                    if (_rubberBandUpSpace && _refreshElement != null && _refreshElement.CanAnimate && !IsRefreshing)
                    {
                        // so it doesn't clip
                        bool show = offset >= _refreshShowOffsetRequired && _isRefreshEnabled;
                        if (show)
                        {
                            if (!_refreshingInitiated && offset >= RefreshingOffsetRequired)
                            {
                                _refreshingInitiated = true;
                                Refreshing?.Invoke(this, EventArgs.Empty);
                            }
                            if (show)
                            {
                                // adjust frame to distance
                                var frame = (int)((offset - _refreshShowOffsetRequired) * _refreshFrameDistanceRatio);
                                ((IAnimatableSpriteProvider)_refreshElement.Source).CurrentFrame = frame % _refreshElement.Frames;
                            }
                        }
                        ShowRefreshElement(show);
                    }
                }
            }

            // round it to pixel accuracy to increase visual precision and reduce amount of rendering?
            foreach (var index in _scrollModeToDirectionIndices)
            {
                if (index == 0)
                    _actualScrollOffsets.X = (float)Math.Round(_actualScrollOffsets.X);
                else
                    _actualScrollOffsets.Y = (float)Math.Round(_actualScrollOffsets.Y);
            }

            if (startScrollOffsets != _actualScrollOffsets)
            {
                if (_rubberBandEntered)
                {
                    UpdateScrollingBarsSize();
                }
                return true;
            }
            return false;
        }

        private float CalcRubberBandOffset(float offset)
        {
            // graph this out to see it, try https://www.desmos.com/calculator
            // [ 50 * ln (x / 40 + 1) ]
            // for an ideal height of 80 pixels, it is arrived at by 158 pixels of translation

            offset = (float)(50.0 * Math.Log(offset / 40.0 + 1.0));
            if (!_rubberBandUpSpace)
                offset = -offset;
            return offset;
        }

        private void UpdateScrollingBarsSize()
        {
            _canScrollContent = false;

            // set the size of the bar we want to show
            foreach (var index in _scrollModeToDirectionIndices)
            {
                var scrollBar = _scrollBars[index];

                // reset the bar size
                var barSize = Vector2.Zero;
                scrollBar.Arrange(ref barSize, false);

                float sizeChildren;
                float sizeViewPort;

                if (index == 0)
                {
                    sizeChildren = VisualContent.ActualWidth + VisualContent.MarginInternal.TotalWidth;
                    sizeViewPort = ViewPort.X;
                }
                else
                {
                    sizeChildren = VisualContent.ActualHeight + VisualContent.MarginInternal.TotalHeight;
                    sizeViewPort = ViewPort.Y;
                }

                if (_rubberBandEntered)
                {
                    sizeViewPort -= Math.Abs(_actualScrollOffsets[index] - _rubberBandStartOffset);
                }
                var canScroll = sizeChildren > sizeViewPort;

                for (var dim = 0; dim < Dims; dim++)
                {
                    float size;
                    if (dim == index)
                    {
                        if (canScroll)
                        {
                            _canScrollContent = true;
                            size = (sizeViewPort / sizeChildren) * sizeViewPort;
                        }
                        else
                        {
                            size = sizeViewPort;
                        }
                    }
                    else
                    {
                        size = Math.Min(ScrollBarThickness + scrollBar.Margin[dim + Thickness.DimOffset], ViewPort[dim]);
                    }
                    barSize[dim] = size;
                }

                scrollBar.Arrange(ref barSize, IsCollapsed);

                if (!ScrollBarHidesNoActivity)
                {
                    scrollBar.Visibility = canScroll ? Visibility.Visible : Visibility.Collapsed;
                }
            }
        }

        private void UpdateVisualContentArrangeMatrix()
        {
            // calculate the offsets to move the element of

            // compute the rendering offsets of the child element wrt the parent origin (0,0)
            var childOffsets = _actualScrollOffsets + new Vector2(Padding.Left, Padding.Top) - _actualViewPort / 2;

            // set the arrange matrix of the child.
            VisualContent.DependencyProperties.Set(ContentArrangeMatrixPropertyKey, Matrix.Translation(childOffsets));

            // force re-calculation of main element and scroll bars world matrices
            ArrangeChanged = true;

            // redraw needed
            IsDirty = true;
        }

        protected override void UpdateWorldMatrix(ref Matrix parentWorldMatrix, bool parentWorldChanged)
        {
            var shouldUpdateScrollBars = parentWorldChanged || ArrangeChanged || LocalMatrixChanged;

            base.UpdateWorldMatrix(ref parentWorldMatrix, parentWorldChanged);

            if (shouldUpdateScrollBars && VisualContent != null)
            {
                // set the world matrices of the scroll bars
                foreach (var index in _scrollModeToDirectionIndices)
                {
                    var scrollBar = _scrollBars[index];
                    var barSize = (Vector2)scrollBar.RenderSizeInternal;
                    barSize = CalculateSizeWithThickness(ref barSize, ref scrollBar.MarginInternal);
                    var barPosition = RenderSize / 2 - new Vector3(barSize, 0f);

                    // adjust the position of the scroll bar
                    var renderSize = index == 0 ? ActualWidth : ActualHeight;
                    float pos = renderSize / -2f;

                    // determine the position ratio of the scroll bar in the viewport
                    if (!_rubberBandEntered)
                    {
                        if (index == 0)
                        {
                            var childMinusParent = VisualContent.DesiredSizeWithMargins.X - ViewPort.X;
                            if (childMinusParent > MathUtil.ZeroTolerance)
                            {
                                var offset = _actualScrollOffsets.X;
                                if (IsRefreshing)
                                    offset -= _refreshShowOffsetRequired;
                                var scrollBarPositionRatio = offset / childMinusParent;
                                pos -= scrollBarPositionRatio * (renderSize - scrollBar.ActualWidth);
                            }
                        }
                        else
                        {
                            var childMinusParent = VisualContent.DesiredSizeWithMargins.Y - ViewPort.Y;
                            if (childMinusParent > MathUtil.ZeroTolerance)
                            {
                                var offset = _actualScrollOffsets.Y;
                                if (IsRefreshing)
                                    offset -= _refreshShowOffsetRequired;
                                var scrollBarPositionRatio = offset / childMinusParent;
                                pos -= scrollBarPositionRatio * (renderSize - scrollBar.ActualHeight);
                            }
                        }
                    }
                    else
                    {
                        if (!_rubberBandUpSpace)
                        {
                            // lock the scrollbar at right/bottom extremity
                            pos = -pos - (index == 0 ? scrollBar.ActualWidth : scrollBar.ActualHeight);
                        }
                    }

                    barPosition[index] = pos;

                    var parentMatrix = WorldMatrix;
                    parentMatrix.TranslationVector += barPosition;

                    ((IUIElementUpdate)scrollBar).UpdateWorldMatrix(ref parentMatrix, true);

                    if (_refreshElement != null && _refreshElement.IsVisible)
                    {
                        UpdateRefreshElementWorldMatrix(index);
                    }
                }
            }
        }

        private bool InitializeRefresh()
        {
            if (_refreshElement == null)
            {
                if (!_isRefreshEnabled || _refreshImage == null)
                    return false;

                _refreshBkgdElement = new Border
                {
                    BackgroundColor = _refreshBkgdColor,
                    HorizontalAlignment = HorizontalAlignment.Left,
                    VerticalAlignment = VerticalAlignment.Top,
                    Visibility = Visibility.Hidden,
                };
                SetVisualParent(_refreshBkgdElement, this);

                _refreshElement = new AnimatedImageElement
                {
                    StretchType = StretchType.None,
                    Visibility = Visibility.Hidden,
                    IsAnimating = false
                };
                SetVisualParent(_refreshElement, this);

                // sort the elements to top so it draws over the VisualContent, below the scrollbars
                VisualChildrenCollection.Remove(_refreshBkgdElement);
                VisualChildrenCollection.Remove(_refreshElement);
                VisualChildrenCollection.Insert(1, _refreshBkgdElement);
                VisualChildrenCollection.Insert(2, _refreshElement);

                UpdateRefreshElement();
            }
            return true;
        }

        private void UpdateRefreshElement()
        {
            foreach (var index in _scrollModeToDirectionIndices)
            {
                // about 100 pixels in a direction for a full rotation of all frames (times a user-controller adjustment factor)
                _refreshFrameDistanceRatio = _refreshImage.SpritesCount / 100f * RefreshFrameDistanceFactor;

                // the sprite can be larger than the texture because of texture regions, which makes the texture not be centered within the sprite
                // this is to get accurate centering of the spin image
                var sprite = _refreshImage.GetSprite();
                var sizeTexture = sprite.Texture.Size;
                _refreshImageTextureOffset = new Vector3(sprite.SizeInPixels.X - sizeTexture.Width, sprite.SizeInPixels.Y - sizeTexture.Height, 0f) / 2f;

                _refreshElement.Source = _refreshImage;
                _refreshElement.Margin = _refreshImageMargin;
                _refreshElement.HorizontalAlignment = index == 0 ? HorizontalAlignment.Left : HorizontalAlignment.Center;
                _refreshElement.VerticalAlignment = index == 0 ? VerticalAlignment.Center : VerticalAlignment.Top;

                _refreshElement.Measure(Vector2.Zero);
                _refreshElement.Arrange(Vector2.Zero, false);

                if (index == 0)
                {
                    _refreshShowOffsetRequired = _refreshElement.ActualWidth + _refreshElement.MarginInternal.TotalWidth;
                    _refreshBkgdElement.Width = _refreshShowOffsetRequired;
                    _refreshBkgdElement.Height = ActualHeight;
                }
                else
                {
                    _refreshShowOffsetRequired = _refreshElement.ActualHeight + _refreshElement.MarginInternal.TotalHeight;
                    _refreshBkgdElement.Width = ActualWidth;
                    _refreshBkgdElement.Height = _refreshShowOffsetRequired;
                }

                _refreshBkgdElement.Measure(Vector2.Zero);
                _refreshBkgdElement.Arrange(Vector2.Zero, false);

                var parentMatrix = WorldMatrix;
                parentMatrix.TranslationVector -= RenderSize / 2f;
                ((IUIElementUpdate)_refreshBkgdElement).UpdateWorldMatrix(ref parentMatrix, true);
            }
        }

        private void OnIsRefreshingChanged()
        {
            if (_isRefreshing)
            {
                if (!InitializeRefresh())
                {
                    _isRefreshing = false;
                    return;
                }

                if (!_refreshingInitiated)
                {
                    // IsRefresing was set true by client code without a pull down
                    _refreshElementFixedAtTop = true;

                    ScrollTo(new Vector2(_refreshShowOffsetRequired));
                }
                else
                {
                    // ease out to bottom of refresh bar instead
                    _rubberBandStartOffset += _refreshShowOffsetRequired;
                }
                _refreshElement.IsAnimating = true;
                _refreshBkgdElement.Visibility = Visibility.Visible;
                ShowRefreshElement(true);
            }
            else
            {
                if (_refreshElement != null)
                {
                    _refreshingInitiated = false;
                    _refreshElementFixedAtTop = false;
                    _refreshElement.IsAnimating = false;
                    _refreshBkgdElement.Visibility = Visibility.Hidden;
                    ShowRefreshElement(false);

                    if (_rubberBandEntered)
                    {
                        _rubberBandStartOffset -= _refreshShowOffsetRequired;
                    }
                }
            }
        }

        private void ShowRefreshElement(bool show)
        {
            var vis = show ? Visibility.Visible : Visibility.Hidden;
            if (vis != _refreshElement.Visibility)
            {
                _refreshElement.Visibility = vis;
                if (show)
                {
                    // so it shows at right position initially
                    foreach (var index in _scrollModeToDirectionIndices)
                        UpdateRefreshElementWorldMatrix(index);
                }
            }
        }

        private void UpdateRefreshElementWorldMatrix(int index)
        {
            var elemPosition = _refreshImageTextureOffset;
            if (_refreshElementFixedAtTop)
            {
                if (index == 0)
                    elemPosition.Y += ActualWidth / -2f;
                else
                    elemPosition.Y += ActualHeight / -2f;
            }
            else
            {
                if (index == 0)
                    elemPosition.X += (_actualScrollOffsets.X - (ActualWidth + _refreshShowOffsetRequired)) / 2f;
                else
                    elemPosition.Y += (_actualScrollOffsets.Y - (ActualHeight + _refreshShowOffsetRequired)) / 2f;
            }

            var parentMatrix = WorldMatrix;
            parentMatrix.TranslationVector += elemPosition;

            ((IUIElementUpdate)_refreshElement).UpdateWorldMatrix(ref parentMatrix, true);
        }

        protected override void OnPreviewTouchDown(TouchEventArgs args)
        {
            base.OnPreviewTouchDown(args);

            if (!_canScrollContent && !IsRubberBandEnabled)
                return;

            StopCurrentScrolling();
            _isTouchedDown = true;
            _accumulatedTouchTranslation = Vector2.Zero;
        }

        protected override void OnPreviewTouchUp(TouchEventArgs args)
        {
            base.OnPreviewTouchUp(args);

            if (IsUserScrollingViewer)
            {
                args.Handled = true;

                // need a copy since args.IsBeingRouted is true
                var argsCopy = new TouchEventArgs
                {
                    Action = args.Action,
                    ScreenPosition = args.ScreenPosition,
                    ScreenTranslation = args.ScreenTranslation,
                    Timestamp = args.Timestamp
                };
                RaiseLeaveTouchEventToHierarchyChildren(this, argsCopy);

                IsUserScrollingViewer = false;
            }

            _isTouchedDown = false;
            _accumulatedTouchTranslation = Vector2.Zero;
        }

        protected override void OnTouchEnter(TouchEventArgs args)
        {
            base.OnTouchEnter(args);

            StopCurrentScrolling();
            _accumulatedTouchTranslation = Vector2.Zero;
        }

        protected override void OnTouchLeave(TouchEventArgs args)
        {
            base.OnTouchLeave(args);

            IsUserScrollingViewer = false;
            _isTouchedDown = false;
            _accumulatedTouchTranslation = Vector2.Zero;
        }

        protected override void OnPreviewTouchMove(TouchEventArgs args)
        {
            base.OnPreviewTouchMove(args);

            if (!_isTouchedDown || ScrollMode == ScrollingMode.None || !TouchScrollingEnabled)
                return;

            // accumulate all the touch moves of the frame
            var translation = args.WorldTranslation;
            foreach (var index in _scrollModeToDirectionIndices)
            {
                if (index == 0)
                    _accumulatedTouchTranslation.X -= translation.X;
                else
                    _accumulatedTouchTranslation.Y -= translation.Y;
            }

            if (!IsUserScrollingViewer)
            {
                if (_accumulatedTouchTranslation.Length() > ScrollStartThreshold)
                {
                    IsUserScrollingViewer = true;
                    _rubberBandEasingOut = false;

                    // start scrolling from this point - avoids 'jump' after threshold reached
                    _accumulatedTouchTranslation = Vector2.Zero;
                }
            }

            if (IsUserScrollingViewer)
                args.Handled = true;
        }

        private static void RaiseLeaveTouchEventToHierarchyChildren(UIElement parent, TouchEventArgs args)
        {
            if (parent == null)
                return;

            foreach (var child in parent.VisualChildrenCollection)
            {
                if (child.IsTouched)
                {
                    child.RaiseTouchLeaveEvent(args);
                    RaiseLeaveTouchEventToHierarchyChildren(child, args);
                }
            }
        }
    }
}
